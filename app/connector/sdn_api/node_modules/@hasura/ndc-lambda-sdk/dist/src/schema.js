"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONValue = exports.BuiltInScalarTypeName = exports.NullOrUndefinability = exports.FunctionNdcKind = void 0;
exports.typePathToString = typePathToString;
exports.typePathSegmentToString = typePathSegmentToString;
exports.getNdcSchema = getNdcSchema;
exports.printSchemaListing = printSchemaListing;
exports.printRelaxedTypesWarning = printRelaxedTypesWarning;
exports.isTypeNameBuiltInScalar = isTypeNameBuiltInScalar;
exports.isBuiltInScalarTypeReference = isBuiltInScalarTypeReference;
const util_1 = require("./util");
var FunctionNdcKind;
(function (FunctionNdcKind) {
    FunctionNdcKind["Function"] = "Function";
    FunctionNdcKind["Procedure"] = "Procedure";
})(FunctionNdcKind || (exports.FunctionNdcKind = FunctionNdcKind = {}));
// If there are compiler errors on this function, ensure that BuiltInScalarTypeDefinition has a type in
// its union for every BuiltInScalarTypeName enum member, and vice versa.
function builtInScalarTypeAssertionTest(a, b) {
    a = b;
    b = a;
}
var NullOrUndefinability;
(function (NullOrUndefinability) {
    NullOrUndefinability["AcceptsNullOnly"] = "AcceptsNullOnly";
    NullOrUndefinability["AcceptsUndefinedOnly"] = "AcceptsUndefinedOnly";
    NullOrUndefinability["AcceptsEither"] = "AcceptsEither";
})(NullOrUndefinability || (exports.NullOrUndefinability = NullOrUndefinability = {}));
var BuiltInScalarTypeName;
(function (BuiltInScalarTypeName) {
    BuiltInScalarTypeName["String"] = "String";
    BuiltInScalarTypeName["Float"] = "Float";
    BuiltInScalarTypeName["Boolean"] = "Boolean";
    BuiltInScalarTypeName["BigInt"] = "BigInt";
    BuiltInScalarTypeName["DateTime"] = "DateTime";
    BuiltInScalarTypeName["JSON"] = "JSON";
})(BuiltInScalarTypeName || (exports.BuiltInScalarTypeName = BuiltInScalarTypeName = {}));
class JSONValue {
    #value = undefined;
    #serializationError;
    constructor(value, lazyValidate = false) {
        if (value === undefined) {
            throw new Error("'value' cannot be undefined");
        }
        if (!lazyValidate) {
            this.#serializationError = this.#validate(value);
            if (this.#serializationError !== null && this.#serializationError !== undefined) {
                throw new Error("The provided value cannot be serialized to JSON", { cause: this.#serializationError });
            }
        }
        this.#value = value;
    }
    #validate(value) {
        try {
            JSON.stringify(value);
            return null;
        }
        catch (e) {
            return e;
        }
    }
    get value() {
        return this.#value;
    }
    /**
     * @internal
     */
    get validationError() {
        if (this.#serializationError === undefined) {
            this.#serializationError = this.#validate(this.#value);
        }
        return this.#serializationError;
    }
}
exports.JSONValue = JSONValue;
function typePathToString(segments) {
    return segments.map(typePathSegmentToString).join(", ");
}
function typePathSegmentToString(segment) {
    switch (segment.segmentType) {
        case "FunctionParameter": return `function '${segment.functionName}' parameter '${segment.parameterName}'`;
        case "FunctionReturn": return `function '${segment.functionName}' return value`;
        case "ObjectProperty": return `type '${segment.typeName}' property '${segment.propertyName}'`;
        case "Array": return `array type`;
        case "TypeParameter": return `type '${segment.typeName}' type parameter index '${segment.index}'`;
        case "IndexSignature": return `type '${segment.typeName}' type signature index '${segment.sigIndex}' ${segment.component} type`;
        case "UnionMember": return `type '${segment.typeName}' union member index '${segment.memberIndex}'`;
        default: return (0, util_1.unreachable)(segment["segmentType"]);
    }
}
function getNdcSchema(functionsSchema) {
    const functions = Object.entries(functionsSchema.functions);
    const objectTypes = (0, util_1.mapObjectValues)(functionsSchema.objectTypes, objDef => {
        return {
            fields: Object.fromEntries(objDef.properties.map(propDef => {
                const objField = {
                    type: convertTypeReferenceToSdkType(propDef.type),
                    ...(propDef.description ? { description: propDef.description } : {})
                };
                return [propDef.propertyName, objField];
            })),
            ...(objDef.description ? { description: objDef.description } : {})
        };
    });
    const scalarTypes = (0, util_1.mapObjectValues)(functionsSchema.scalarTypes, (scalarDef, scalarTypeName) => {
        switch (scalarDef.type) {
            case "built-in":
                return isTypeNameBuiltInScalar(scalarTypeName)
                    ? convertBuiltInScalarTypeIntoSdkSchemaType(scalarTypeName)
                    : (0, util_1.throwError)(`built-in scalar type with unexpected name: ${scalarTypeName}`);
            case "relaxed-type":
                return {
                    aggregate_functions: {},
                    comparison_operators: {},
                };
            default:
                return (0, util_1.unreachable)(scalarDef["type"]);
        }
    });
    return {
        functions: functions
            .filter(([_, def]) => def.ndcKind === FunctionNdcKind.Function)
            .map(([name, def]) => convertFunctionDefinitionToSdkSchemaType(name, def)),
        procedures: functions
            .filter(([_, def]) => def.ndcKind === FunctionNdcKind.Procedure)
            .map(([name, def]) => convertFunctionDefinitionToSdkSchemaType(name, def)),
        collections: [],
        object_types: objectTypes,
        scalar_types: scalarTypes,
    };
}
function convertTypeReferenceToSdkType(typeRef) {
    switch (typeRef.type) {
        case "array": return { type: "array", element_type: convertTypeReferenceToSdkType(typeRef.elementType) };
        case "nullable": return { type: "nullable", underlying_type: convertTypeReferenceToSdkType(typeRef.underlyingType) };
        case "named": return { type: "named", name: typeRef.name };
        default: return (0, util_1.unreachable)(typeRef["type"]);
    }
}
function convertBuiltInScalarTypeIntoSdkSchemaType(typeName) {
    switch (typeName) {
        case BuiltInScalarTypeName.String: return {
            representation: { type: "string" },
            aggregate_functions: {},
            comparison_operators: { "_eq": { type: "equal" } },
        };
        case BuiltInScalarTypeName.Float: return {
            representation: { type: "float64" },
            aggregate_functions: {},
            comparison_operators: { "_eq": { type: "equal" } },
        };
        case BuiltInScalarTypeName.Boolean: return {
            representation: { type: "boolean" },
            aggregate_functions: {},
            comparison_operators: { "_eq": { type: "equal" } },
        };
        case BuiltInScalarTypeName.BigInt: return {
            representation: { type: "biginteger" },
            aggregate_functions: {},
            comparison_operators: { "_eq": { type: "equal" } },
        };
        case BuiltInScalarTypeName.DateTime: return {
            representation: { type: "timestamp" },
            aggregate_functions: {},
            comparison_operators: { "_eq": { type: "equal" } },
        };
        case BuiltInScalarTypeName.JSON: return {
            representation: { type: "json" },
            aggregate_functions: {},
            comparison_operators: {},
        };
        default: return (0, util_1.unreachable)(typeName);
    }
}
function convertFunctionDefinitionToSdkSchemaType(function_name, definition) {
    const args = definition.arguments
        .map(argDef => [argDef.argumentName,
        {
            type: convertTypeReferenceToSdkType(argDef.type),
            ...(argDef.description ? { description: argDef.description } : {}),
        }
    ]);
    return {
        name: function_name,
        arguments: Object.fromEntries(args),
        result_type: convertTypeReferenceToSdkType(definition.resultType),
        ...(definition.description ? { description: definition.description } : {}),
    };
}
function printSchemaListing(functionNdcKind, functionDefinitions) {
    const functions = Object.entries(functionDefinitions).filter(([_, def]) => def.ndcKind === functionNdcKind);
    if (functions.length > 0) {
        console.error(``);
        console.error(`${functionNdcKind}s:`);
        for (const [functionName, functionDefinition] of functions) {
            const args = functionDefinition.arguments.join(', ');
            console.error(`* ${functionName}(${args})`);
        }
        console.error(``);
    }
}
function printRelaxedTypesWarning(functionsSchema) {
    const relaxedTypes = Object.entries(functionsSchema.scalarTypes).flatMap(([scalarTypeName, definition]) => {
        return definition.type === "relaxed-type"
            ? [[scalarTypeName, definition]]
            : [];
    });
    if (relaxedTypes.length > 0) {
        console.error("The following unsupported types have been defined as custom scalar types with no runtime validation ('relaxed types').");
        console.error("Use of relaxed types may cause runtime issues if invalid values are passed for these types.");
        console.error("It is recommended that you replace them with equivalent supported types so that your schema can be properly defined and validated, then remove the @allowrelaxedtypes tag from the functions involved.");
        for (const [scalarTypeName, definition] of relaxedTypes) {
            console.error(`  * '${scalarTypeName}' - used in:`);
            for (const usedIn of definition.usedIn) {
                console.error(`    * ${typePathToString(usedIn)}`);
            }
        }
    }
}
function isTypeNameBuiltInScalar(typeName) {
    return Object.values(BuiltInScalarTypeName).find(builtInScalarTypeName => typeName === builtInScalarTypeName) !== undefined;
}
function isBuiltInScalarTypeReference(typeReference) {
    return isTypeNameBuiltInScalar(typeReference.name);
}
//# sourceMappingURL=schema.js.map